Angular FormFoundry — Angular app blueprint (form builder + response inbox) + Neon backend

What it is

FormFoundry is a form builder where you design forms (fields, validation, sections) and then collect responses into an inbox with export. This is not a grid schema generator (that’s GridSmith) and not a “card publisher” — it’s form definition + submission pipeline.


---

Architecture

Flow: Angular UI → API → Neon
Neon access server-only.

Identity (v1, no auth)

device_key UUID in localStorage

X-Device-Key header

server maps to user_id


Public access:

anyone can submit to a published form via /f/:publicSlug

owner manages forms + inbox behind device_key



---

Data model (Neon Postgres)

sql/002_formfoundry.sql

create extension if not exists pgcrypto;

create table if not exists users (
  id uuid primary key default gen_random_uuid(),
  device_key text not null unique,
  created_at timestamptz not null default now()
);

create table if not exists forms (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references users(id) on delete cascade,
  name text not null,
  status text not null default 'draft' check (status in ('draft','published')),
  public_slug text null unique,
  schema jsonb not null,                   -- form definition
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists form_responses (
  id uuid primary key default gen_random_uuid(),
  form_id uuid not null references forms(id) on delete cascade,
  submitted_at timestamptz not null default now(),
  response jsonb not null,                 -- answers
  meta jsonb not null default '{}'::jsonb   -- ip/user agent (optional)
);

create index if not exists idx_forms_user on forms(user_id, updated_at desc);
create index if not exists idx_responses_form on form_responses(form_id, submitted_at desc);

Schema JSON contract (stable)

{
  "title": "Contact Form",
  "sections": [
    {
      "title": "Basics",
      "fields": [
        { "key": "name", "label": "Name", "type": "text", "required": true },
        { "key": "email", "label": "Email", "type": "email", "required": true },
        { "key": "reason", "label": "Reason", "type": "select", "options": ["quote","support","other"] }
      ]
    }
  ]
}


---

API surface

Base: /api/forms

Owner

GET /api/forms

POST /api/forms { name, schema }

GET /api/forms/:id

PATCH /api/forms/:id { name?, schema?, status? }

POST /api/forms/:id/publish → creates public_slug

DELETE /api/forms/:id


Responses (owner)

GET /api/forms/:id/responses?limit=100&cursor=...

DELETE /api/responses/:responseId


Public submission

POST /api/public/forms/:publicSlug/submit { response }


Caps

max fields per form: 200

max response size: 32KB

basic spam guard: per-IP throttling (boring)



---

Angular app pages (MVP)

/ Forms list

/builder/:id Form builder

/inbox/:id Responses inbox

/f/:publicSlug Public form renderer



---

UI/UX (MVP)

Forms list

create new form

publish/unpublish

copy public link


Builder

left: sections/fields tree

center: field editor (label/type/required/options)

right: live preview

validation: schema sanity check


Inbox

table list of responses

click to open full response JSON

export CSV (server generates)


Public form

renders from schema

client-side validation matching schema

submit to public endpoint



---

Smoke tests

1. Create form with 3 fields


2. Publish → get public link


3. Submit response as “public user”


4. Inbox shows response


5. Export CSV contains submitted fields




---

Done definition

Done = Angular can build/publish a form schema, accept public submissions, and show responses inbox with export—persisted in Neon.

