Remix VaultKey — Remix app blueprint (sealed notes with envelope encryption) + Neon backend

What it is

VaultKey is a Remix app for storing “sealed entries” (text blobs) where the server never stores plaintext—only encrypted payloads. You unlock with a passphrase per session. This is neither a queue app nor a card/publish app nor a saved-views app. It’s encryption + key-handling + secure UX.


---

Security model (MVP, practical)

User provides a passphrase (not stored).

App derives a key using PBKDF2 (WebCrypto) with a per-entry salt.

Encrypt entry body with AES-GCM.

Store only:

salt

iv

ciphertext

metadata (title/tags/created_at)



Important constraint: because Remix runs server-side, you can do encryption on:

Client-side (preferred): passphrase never leaves the browser.

Server receives ciphertext only.


That keeps it clean.


---

Architecture

Flow: Remix UI → Remix actions/loaders → Neon
Encryption happens in the browser; server stores encrypted bytes.

Identity (v1)

No accounts required.

Optional APP_PASSCODE to protect the app UI itself.

“Session unlock” is local-only in the browser.



---

Data model (Neon Postgres)

sql/002_vaultkey.sql

create extension if not exists pgcrypto;

create table if not exists sealed_entries (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  tags text[] not null default '{}',
  salt bytea not null,
  iv bytea not null,
  ciphertext bytea not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_sealed_entries_time on sealed_entries(created_at desc);
create index if not exists idx_sealed_entries_tags on sealed_entries using gin(tags);


---

Routes/pages

/ list sealed entries (title/tags/time)

/new create entry

/e/:id view/decrypt entry

/settings unlock/lock controls (optional)



---

UI/UX (MVP)

Unlock flow

user enters passphrase

browser derives a session key (kept in memory)

show “Unlocked” indicator + lock button


Create entry

title

tags

body (plaintext in editor)

on save:

browser encrypts body → sends ciphertext + salt + iv to server action

server stores encrypted record

plaintext never sent



View entry

server loader returns ciphertext + salt + iv + metadata

browser decrypts if unlocked

display plaintext


Export

export entry (ciphertext package) for backup

import package (optional)



---

Crypto details (boring + correct)

KDF: PBKDF2 with SHA-256

iterations: 210,000 (configurable; keep stable)

key length: 256-bit

encryption: AES-GCM with random 12-byte IV

salt: random 16 bytes



---

Safety rules

Max entry body length (e.g., 200k chars)

Never log passphrase

Never persist passphrase in localStorage (memory only)

“Lock” clears key from memory and reloads page



---

Smoke tests

1. Unlock with passphrase


2. Create entry with body text


3. Entry list shows metadata only


4. Open entry → decrypt shows body


5. Lock → entry becomes unreadable until unlock




---

Done definition

Done = entries are encrypted client-side, stored encrypted in Neon, and decryptable only with user passphrase in-session.

